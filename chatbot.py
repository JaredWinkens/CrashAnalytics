from google import genai
from google.genai import types
import pandas as pd
import sqlite3
import json

MODEL = "gemini-2.0-flash"
DATABASE = "data/crash_data.db"
CSV_FILE = "data/Combined_Data.csv"
TABLE_NAME = "combined_data"
METADATA_PATH = "data/combined_data_metadata.json"

def csv_to_sql_table():

    df = pd.read_csv(CSV_FILE)

    conn = sqlite3.connect(DATABASE)
    
    df.to_sql(TABLE_NAME, conn, if_exists='replace', index=False)

    conn.close()
    print("Data imported successfully")

def get_sql_table_schema():
    conn = sqlite3.connect(DATABASE)
    cursor = conn.cursor()
    cursor.execute(f"PRAGMA table_info({TABLE_NAME})")
    table_info = cursor.fetchall()
    conn.close()

    schema = {'table_name': TABLE_NAME, 'columns': []}
    for row in table_info:
        schema['columns'].append({
            'column_name': row[1],
            'column_type': row[2],
        })
    return schema

def schema_to_json_file(schema):
    try:
        with open(METADATA_PATH, 'w') as jsonfile:
            json.dump(schema, jsonfile, indent=4)
        print(f"SQL schema saved to '{METADATA_PATH}'")
    except Exception as e:
        print(f"Error saving schema to JSON: {e}")

client = genai.Client(api_key="AIzaSyBQ2Ca6HSly3DdXo4e35Nd1PjoroVSyFzs")

metadata = str(get_sql_table_schema())
print(metadata)

# Initilize the purpose of the translator module
translator_module_role = f"""
Your purpose is to convert user input into SQL queries that can be executed on an SQL table to retrieve data.

You will always be given 2 inputs respectively: 
1. The user's input.
2. A json string containing the metadata of the SQL table

Make sure to only output the raw SQL query code. Do not add any other characters or whitespace.

If for some reason SQL code can not be generated, respond with the reason why and start the sentence with `#`. 
"""

# Initilize the purpose of the output module
ouput_module_role = """
Your purpose is to transform raw SQL query results into a highly informative, user-friendly, and actionable format.

Note: The SQL code that was used to fetch these results was generated by a LLM that translated user input into SQL query code.
You will be provided with the original user input for context.

You will always be given 2 inputs respectively:
1. The raw SQL query result(s)
2. The original user input

Focus on clarity, conciseness, and immediate comprehensibility for a non-technical audience.
"""
def generate_response(user_input):

    # Human-to-SQL Translator Module
    translator_response = client.models.generate_content(
        model=MODEL,
        config=types.GenerateContentConfig(
            system_instruction=translator_module_role,
            temperature=0,
            ),
        contents=[user_input, metadata]
    )
    print("TRANSLATOR REPSONSE: ", translator_response.text)

    # Get the result of the query
    query = translator_response.text.strip("```sql") # Remove sql watermark
    query = query.strip() # Remove all whitespace
    query_result = ""
    if (query.startswith('#')):
        query_result = translator_response.text 
    else:
        # Execute SQL Query
        conn = sqlite3.connect(DATABASE)
        cursor = conn.cursor()

        try:
            cursor.execute(query)
            query_result = str(cursor.fetchall())
        except Exception as e:
            print(f"Error executing SQL query: {e}")
            query_result = str(e)
        #result = pd.read_sql_query(query, conn)
        #query_result = result.to_string()

        conn.close()  # Close the connection
    print("QUERY RESULT: ", query_result)

    # Output Formater Module
    output_response = client.models.generate_content(
        model=MODEL,
        config=types.GenerateContentConfig(
            system_instruction=ouput_module_role,
            temperature=0,
        ),
        contents=[query_result, user_input]
    )
    print("OUTPUT: ",output_response.text)
    return output_response.text

def main():
    
    while (True):

        user_input = input("Type Your Question (\q to quit): ")

        if (user_input == "\q"):
            break

        generate_response(user_input)
    
if __name__ == "__main__":
    main()
    


    